# 图中点的层次

给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环。

所有边的长度都是 1，点的编号为 1∼n。

请你求出 1 号点到 n 号点的最短距离，如果从 1 号点无法走到 n 号点，输出 −1。

#### 输入格式

第一行包含两个整数 n 和 m。

接下来 m 行，每行包含两个整数 a 和 b，表示存在一条从 a 走到b 的长度为 1 的边。

#### 输出格式

输出一个整数，表示 1 号点到 n 号点的最短距离。

#### 数据范围

1≤n,m≤10<sup>5</sup>

#### 输入样例：

```
4 5
1 2
2 3
3 4
1 3
1 4
```

#### 输出样例：

```
1
```

# 题解

判断1号节点能否走到n号节点，广度优先遍历即可。

**思路：**从起点开始，往前走第一步，记录下所有第一步能走到的点。然后从所第一步能走到的点开始，往前走第二步，记录下所有第二步能走到的点，重复下去，直到走到终点。输出步数即可。

这就是广度优先遍历的思路。

**实现方式**：

- 根据输入，构建存储图的邻接表。
- 从起点开始广度优先遍历图。
- 当图遍历完，就求出了起点到各个点的距离。
- `int dist[N];`存储起点到其他点的距离
- `void bfs()`:广度优先遍历图
- ` queue<int> q;`用来存储相同部署能走到的点。
- `  while(q.size())`:循环依次取出同一步数能走到的点，再往前走一步。
- ` for(int i = h[t]; i != -1; i = ne[i])`:遍历所有t节点能到的点，i为t能走到的节点的索引。

**代码**：

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>
using namespace std;

const int N = 100010;

int h[N],ne[N], e[N], idx;//邻接表数据结构
int dist[N];//存储距离
int st[N];//标记点是否走到过
int n, m;

void add(int a, int b)//邻接表存储图
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

void bfs()
{
    memset(dist, 0x3f, sizeof(dist));//初始都没有走到过，距离无穷大
    dist[1] = 0;//从1号节点开始，距离为0
    queue<int> q;//队列
    q.push(1);//1号节点入队列
    st[1] = 1;//1到1的距离为0，已经求出
    while(q.size())//对列非空，就一直往后搜索
    {
        int t = q.front();//队头出队，找该点能到的点
        q.pop();
        for(int i = h[t]; i != -1; i = ne[i])//遍历所有t节点能到的点，i为节点索引
        {
            int j = e[i];//通过索引i得到t能到的节点编号
            if(!st[j])//如果没有遍历过
            {
                dist[j] = dist[t] + 1;//距离为t号节点的距离+1
                q.push(j);//节点入队
                st[j] = 1;//入队后标记，已经遍历过了
            }
        }
    }
}

int main()
{
    cin >> n >>m;
    memset(h, -1, sizeof h);//初始化，所有节点没有后继，后继都是-1
    for(int i = 0; i < m; i++)//读入所有边
    {
        int a, b;
        cin >> a >> b;
        add(a, b);//加入邻接表
    }
    bfs();//广度优先遍历

    cout << (dist[n] == 0x3f3f3f3f ? -1 : dist[n]);//如果到n号节点的距离不是无穷大，输出距离，如果是无穷大，输出-1.
    return 0;
}

```

## 评论

- 存储距离的数组dist[ ]可以实现标记数组的功能，当遍历到的当前结点的距离为-1（默认值）时，表示当前结点没有被访问，否则就是已经被访问过的结点，并且当前标记值就是起始结点到当前结点的距离。
  - 可以