# 数字排列

## 题目描述

给定一个整数 n，将数字 1∼n 排成一排，将会有很多种排列方法。

现在，请你按照字典序将所有的排列方法输出。

#### 输入格式

共一行，包含一个整数 n。

#### 输出格式

按字典序输出所有排列方案，每个方案占一行。

#### 数据范围

1≤n≤7

#### 输入样例：

```
3
```

#### 输出样例：

```
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
```

## 题解

如何用 dfs 解决全排列问题？

dfs 最重要的是搜索顺序。用什么顺序遍历所有方案。

对于全排列问题，以 n = 3 为例，可以这样进行搜索：（先看文字再看图）

![深度优先遍历.png](https://cdn.acwing.com/media/article/image/2021/02/20/55289_0cd4222d73-深度优先遍历.png) 


假设有 3 个空位，从前往后填数字，每次填一个位置，填的数字不能和前面一样。

最开始的时候，三个空位都是空的：\_\_ \_\_  \_\_

首先填写第一个空位，第一个空位可以填 1，填写后为：1 \_\_  \_\_

填好第一个空位，填第二个空位，第二个空位可以填 2，填写后为：1 2  \_\_

填好第二个空位，填第三个空位，第三个空位可以填 3，填写后为： 1 2 3

**这时候，空位填完，无法继续填数，所以这是一种方案，输出。**

然后往后退一步，退到了状态：1 2  \_\_ 。剩余第三个空位没有填数。第三个空位上除了填过的 3 ，没有其他数字可以填。

因此再往后退一步，退到了状态：1 \_\_ \_\_。第二个空位上除了填过的 2，还可以填 3。第二个空位上填写 3，填写后为：1 3 \_\_

填好第二个空位，填第三个空位，第三个空位可以填 2，填写后为： 1 3 2

**这时候，空位填完，无法继续填数，所以这是一种方案，输出。**

然后往后退一步，退到了状态：1 3  \_\_ 。剩余第三个空位没有填数。第三个空位上除了填过的 2，没有其他数字可以填。

因此再往后退一步，退到了状态：1 \_\_ \_\_。第二个空位上除了填过的 2，3，没有其他数字可以填。

因此再往后退一步，退到了状态：\_\_ \_\_ \_\_。第一个空位上除了填过的 1，还可以填 2。第一个空位上填写 2，填写后为：2 \_\_ \_\_

填好第一个空位，填第二个空位，第二个空位可以填 1，填写后为：2 1  \_\_

填好第二个空位，填第三个空位，第三个空位可以填 3，填写后为：2 1 3

**这时候，空位填完，无法继续填数，所以这是一种方案，输出。**

然后往后退一步，退到了状态：2 1  \_\_ 。剩余第三个空位没有填数。第三个空位上除了填过的 3，没有其他数字可以填。

因此再往后退一步，退到了状态：2 \_\_ \_\_。第二个空位上除了填过的 1，还可以填 3。第二个空位上填写 3，填写后为：2 3 \_\_

填好第二个空位，填第三个空位，第三个空位可以填 1，填写后为：2 3 1

**这时候，空位填完，无法继续填数，所以这是一种方案，输出。**

然后往后退一步，退到了状态：2 3  \_\_ 。剩余第三个空位没有填数。第三个空位上除了填过的 1，没有其他数字可以填。

因此再往后退一步，退到了状态：2 \_\_ \_\_。第二个空位上除了填过的 1，3，没有其他数字可以填。

因此再往后退一步，退到了状态：\_\_ \_\_ \_\_。第一个空位上除了填过的 1，2，还可以填 3。第一个空位上填写 3，填写后为：3 \_\_ \_\_

填好第一个空位，填第二个空位，第二个空位可以填 1，填写后为：3 1  \_\_

填好第二个空位，填第三个空位，第三个空位可以填 2，填写后为：3 1 2

**这时候，空位填完，无法继续填数，所以这是一种方案，输出。**

然后往后退一步，退到了状态：3 1  \_\_ 。剩余第三个空位没有填数。第三个空位上除了填过的 2，没有其他数字可以填。

因此再往后退一步，退到了状态：3 \_\_ \_\_。第二个空位上除了填过的 1，还可以填 2。第二个空位上填写 2，填写后为：3 2 \_\_

填好第二个空位，填第三个空位，第三个空位可以填 1，填写后为：3 2 1

**这时候，空位填完，无法继续填数，所以这是一种方案，输出。**

然后往后退一步，退到了状态：3 2  \_\_ 。剩余第三个空位没有填数。第三个空位上除了填过的 1，2，没有其他数字可以填。

因此再往后退一步，退到了状态：3 \_\_ \_\_。第二个空位上除了填过的 1，2，没有其他数字可以填。

因此再往后退一步，退到了状态：\_\_ \_\_ \_\_。第一个空位上除了填过的 1，2，3，没有其他数字可以填。

**此时深度优先搜索结束，输出了所有的方案。**



---

#### 算法：

- 用 path 数组保存排列，当排列的长度为 n 时，是一种方案，输出。
- 用 state 数组表示数字是否用过。当 state\[i] 为 1 时：i 已经被用过，state\[i] 为 0 时，i 没有被用过。
- dfs(i) 表示的含义是：在 path[i]  处填写数字，然后递归的在下一个位置填写数字。
- 回溯：第 i 个位置填写某个数字的所有情况都遍历后， 第 i 个位置填写下一个数字。

---

#### 代码

```cpp
#include<iostream>
using namespace std;
const int N = 10;
int path[N];//保存序列
int state[N];//数字是否被用过
int n;
void dfs(int u)
{
    if(u > n)//数字填完了，输出
    {
        for(int i = 1; i <= n; i++)//输出方案
            cout << path[i] << " ";
        cout << endl;
    }

    for(int i = 1; i <= n; i++)//空位上可以选择的数字为:1 ~ n
    {
        if(!state[i])//如果数字 i 没有被用过
        {
            path[u] = i;//放入空位
            state[i] = 1;//数字被用，修改状态
            dfs(u + 1);//填下一个位
            state[i] = 0;//回溯，取出 i
        }
    }
}

int main()
{

    cin >> n;
    dfs(1);
}

```

---

时间复杂度为 O(n*n!)。

空间复杂度为 O(n)。

## 评论与答疑

- 个人理解，递归就是实现位数之间的横向移动，遍历就是实现每一位上的纵向移动，两者结合就是全排列。有多少位，就有多少层，所以这个需要把数字竖过来放去想象dfs的搜索树结构，会更直观一点。
- 思路完全理解，但是深究代码，还是觉得 不完全理解，输出一种方案后，例如输出1，2，3后，代码中如何实现回溯的？
  - for循环里面dfs调用结束之后，返回dfs这地方，继续执行dfs的下一条语句，再加上外面的for循环，要从1到3，完成回溯的。
  - 回溯操作在return，return完这个递归就结束了，然后恢复现场，而你看懂没，这个u是一直没变过的，这样也就保证我每次都是从头开始遍历，我函数结束的条件就是for循环结束，也就是说for循环的作用其实就是开个排列的头，举个例子就是我for循环开头1，就从1开始递归下去，知道我把1到n个数都找完，也就是我把位子都填满，这个递归才会结束，但是这个递归还会返回上一层，比如1234返回，然后就1243，比较抽象，这个过程，也就是我填完4的时候，他会到递归到下一个位子，然后再来一遍循环，找到3填上去，然后输出，这个循环结束，然后再找到上面的循环，也就是13开头了，然后再往下走再遍历一遍找到2，然后再往下走.....
  - 一直写法是u+1而不是u++,u本身不变，然后数组一直被覆盖就输出了。
  - 个人理解，递归就是实现位数之间的横向移动，遍历就是实现每一位上的纵向移动，两者结合就是全排列。有多少位，就有多少层，所以这个需要把数字竖过来放去想象dfs的搜索树结构，会更直观一点。
- 您好，从12，到13的代码过渡是哪里啊？
  - for循环里，从12到下一层递归123，下一层递归结束后返回，再走13
- 在递归过程中for循环中的i＋＋是什么时候执行的啊？在进入dfs（u）时循环并未结束即i＋＋并未执行啊？
  - 当u=1时第一次for循环，state[i] = 1;//数字被用，修改状态，所以进入d f s（2）的for循环时，不会在i=1时进入if语句，这个时候会i++。
- state[i] = 0;//回溯，取出 i 这个要怎么样才能能进去，他上面每次都被重新dfs了是不是不会到下面的回溯？
  - 在第一次查询第一个位置是1的时候，后面的2和3还没查询，然后下面的dfs(u+1)直接递归了第二个位置，当你所有位置查询完以后,然后系统会自己再回来继续循环完剩下的位置。y总里面有说系统里有一个隐藏的栈会帮我们维护数组就是说的这个。
- 为什么main函数中是dfs（1）啊？
  - 0和1都行，自己数清楚填了几个数就好。
  - 看他结束递归条件。
- 我想问下为什么不需要在if(u>n)里return呢？
  - return 也对，因为当u>n的时候，各个位置都填上了，所以走到for循环，里面的if都是假，然后程序就结束了。
  - 在它要结束的时候那个for循环会回溯到3，然后再i++，变成4,根本进不去for循环，而且它此时的dfs函数也没有任何可以做的其他程序了，所以这儿不需要（u>n）也能结束dfs这个函数的。