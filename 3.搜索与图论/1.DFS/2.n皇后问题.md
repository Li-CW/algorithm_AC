# n-皇后问题

## 题目描述

n−皇后问题是指将 n 个皇后放在 n×n的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。

![1_597ec77c49-8-queens.png](https://cdn.acwing.com/media/article/image/2019/06/08/19_860e00c489-1_597ec77c49-8-queens.png)

现在给定整数 n，请你输出所有的满足条件的棋子摆法。

#### 输入格式

共一行，包含整数 n。

#### 输出格式

每个解决方案占 n 行，每行输出一个长度为 n 的字符串，用来表示完整的棋盘状态。

其中 `.` 表示某一个位置的方格状态为空，`Q` 表示某一个位置的方格上摆着皇后。

每个方案输出完成后，输出一个空行。

**注意：行末不能有多余空格。**

输出方案的顺序任意，只要不重复且没有遗漏即可。

#### 数据范围

1≤n≤9

#### 输入样例：

```
4
```

#### 输出样例：

```
.Q..
...Q
Q...
..Q.

..Q.
Q...
...Q
.Q..
```

## 题解

深度优先遍历dfs。

**思路：**每一行必定有一个皇后，对行进行深度遍历。

对于第 r 行的第 i 个位置，判断每个点是否可以放皇后，如果可以，则放皇后，然后处理 r + 1 行。

直到 r = n，程序指行完毕。

**实现方式**：深度优先遍历

- 函数名：```void dfs(int r)```: 深度优先遍历函数。参数`r`：从第`r`行开始放棋子，处理第`r`行。

- 递归结束判定：`见代码`，当 `r == n`的时候，说明应该处理第 `n`行了，也代表第 `0~n-1`行放好棋子，也就是整个棋盘放好了棋子，也就是得到了一种解，也就是递归结束。

- 如何判定第`r`行，第`i`列能不能放棋子：

  用数组`dg` `udg` `cor` 分别表示：点对应的两个斜线以及列上是否有皇后。

  `dg[i + r]` 表示 `r`行`i`列处，所在的对角线上有没有棋子，`udg[n - i + r]`表示 `r`行`i`列处，所在的反对角线上有没有棋子，`cor[i]`表示第`i`列上有没有棋子。如果 `r`行`i`列的对角线，反对角线上都没有棋子，即`!cor[i] && !dg[i + r] && !udg[n - i + r]`为真，则代表 `r`行`i`列处可以放棋子。
  
  [点击看大图](https://git.acwing.com/Hasity/jnu/-/raw/master/acwing/n-hh.png)

![n-hh](https://git.acwing.com/Hasity/jnu/-/raw/master/acwing/n-hh.png)

```cpp
//cpp
#include <iostream>
using namespace std;

const int N = 11;

char q[N][N];//存储棋盘
bool dg[N * 2], udg[N * 2], cor[N];//点对应的两个斜线以及列上是否有皇后

int n;

void dfs(int r)
{
    //递归结束判定
    if(r == n)//放满了棋盘，输出棋盘
    {
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < n; j++)
                cout << q[i][j];
            cout << endl;
        }
        cout << endl;
        return;
    }
	//第r行的第i列尝试放棋子
    for(int i = 0; i < n; i++)//第 r 行，第 i 列 是否放皇后
    {
        if(!cor[i] && !dg[i + r] && !udg[n - i + r])//不冲突，放皇后
        {
            q[r][i] = 'Q';
            cor[i] = dg[i + r] = udg[n - i + r] = 1;//对应的 列， 斜线 状态改变
            dfs(r + 1);//处理下一行
            cor[i] = dg[i + r] = udg[n - i + r] = 0;//恢复现场
            q[r][i] = '.';
        }
    }
}

int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            q[i][j] = '.';
    dfs(0);
    return 0;
}

```

## 评论

- 博主大大，你的代码中的cout << q[i]\[j];是用cout通过2个for循环输出的棋盘，y总用的是puts通过1个for循环输出的（puts(g[i]);）。请问y总的代码为什么1行循环就能输出整个2维数组呢？
  - g[i] 就是输出了一行。
- 请问下大佬为啥 dg[] 和 udg[] 要开 2 * N 鸭？
  - 因为是n * n的矩阵，存在r + i也就是行加上列求截距的操作，必须开两倍大否则就爆了。
- 楼主 i + r 和 n - i + r 我知道求的是斜线和反斜线的斜距，但是我不明白为什么能限制每一个皇后都不是同一条斜线？
  - 因为同一个斜线上有皇后的时候，!dg[i + r] && !udg[n - i + r] 不成立，无法进入循环，代表该位置无法放皇后。
- 请问如何dg[N * 2], udg[N * 2]s是代表斜线？
  - 同一条斜线上i + j 和 i - j 相等。
- 楼主，你图里标的回溯是哪一行代码实现的？
  - 唔 不请自来 回溯其实是通过一次完整搜索后满足条件输出后的 return; 语句来实现的（个人理解 应该没错~）
  - 不一定是return出来,一部分是下面的dfs都不满足判断条件故而从for循环那边 继续往下搜。
  - 输出没问题是根据return回溯的,其他不满足条件的皇后站位就是无法进入r==n的判定中,所以等这个for循环结束自动从dfs的尾巴出来,同样也是另一种回溯。
- 楼主 q\[r][i] = ‘.’;这一步是在干什么呢 也是恢复？ 恢复的是哪个位置呢?
  - 处理该行下一个位置时，上次放的那个位置要变回点。
  - 我怎么感觉是回溯的时候要变成’.’呢，处理下一行的时候已经进入递归了。
  - 处理下一个位置的时候说明回溯到这个位置了，都一样的。