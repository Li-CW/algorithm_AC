# 第k个数

给定一个长度为 n 的整数数列，以及一个整数 k，请用快速选择算法求出数列从小到大排序后的第 k 个数。

#### 输入格式

第一行包含两个整数 n 和 k。

第二行包含 n 个整数（所有整数均在 1∼10<sup>9</sup>范围内），表示整数数列。

#### 输出格式

输出一个整数，表示数列的第 k 小数。

#### 数据范围

1≤n≤100000
1≤k≤n

#### 输入样例：

```
5 3
2 4 1 5 3
```

#### 输出样例：

```
3
```

## 题解

### 题意解读

题目给一个无序数组，要输出将这个数组排好序后，数组第k个数字。

### 思路分析

快速选择算法：

- 选取一个基准（参考快排），将数组分成左右两个部分，右边部分大于等于左边部分。
- 根据数组分界位置与k的大小关系，判断要找的数字是在左半部分还是右半部分。
- 对存在要找数字的那半部分数组递归处理，直到待处理的数组中只剩下一个数，这个数字就是要找的那个。

### 举例

对于数组：2 4 1 5 3 找排序后第3个数字。（数组元素下标从1开始）

- 选基准，分数组：选基准2，将数组分成：2 ，1 | 4，5，3 两部分。
- 判断分界线与3的关系：分界线在数组的第 2和3个元素之间，因为划分后数组右半部分大于等于左边部分，因此，排序后，第3个数字一定在右半部分数组。
- 选基准，划分右半部分数组：选基准4，划分后整个数组的情况为：2，1| 4 , 3 | 5
- 判断上一步分界线与3的关系：分界线在数组的第4和5个元素之间，因为划分后数组右半部分大于等于左边部分，因此，排序后，第3个数字一定在左半部分数组。也就是在2，1| **4 , 3** | 5 粗体部分中。
- 选基准，划分粗体部分数组：选基准4，划分后整个数组的情况为：2，1| 3 | 4 | 5。
- 判断上一步分界线与3的关系：分界线在数组的第3和4个元素之间，因为划分后数组右半部分大于等于左边部分，因此，排序后，第3个数字一定在左半部分数组。也就是在2，1| **3** | 4 | 5。 粗体部分中。
- 此时，粗体部分就一个数字，就是要找的：将这个数组排好序后，数组第3个数字。

### 代码

```cpp
#include <iostream>
using namespace std;
const int N = 100010;
int a[N];
int n, k;

int findK(int a[], int l, int r, int k){
    //数组中就剩一个数了，就是要找的那个数字
    if(l >= r) return a[l];
    //选分界线，划分数组。这里选的是中间的数字
    int x = a[l + r >> 1];
    int i = l - 1, j = r + 1;
    while(i < j){
        while(a[++i] < x);
        while(a[--j] > x);
        if(i < j){
            swap(a[i], a[j]);
        }
    }
    //判断分界线与k的关系，
    //如果k在分界线左边，处理左半部分数组
    //注意：这里j是数组下标从0开始，k是从1开始编号的，
    //j指向的是第 j + 1 个元素。
    if(j + 1 >= k)
        return findK(a, l, j, k);
    //否则k在分界线右边，处理左半部分数组
    else 
        return findK(a, j + 1, r, k);
}

int main(){
    cin >> n >> k;
    for(int i = 0; i < n; i++){
        cin >> a[i];
    }
    int res = findK(a, 0, n - 1, k);
    cout << res;
}
```

