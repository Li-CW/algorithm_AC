# 走迷宫

## 题目描述

给定一个 n×m的二维整数数组，用来表示一个迷宫，数组中只包含 0或 1，其中 0 表示可以走的路，1 表示不可通过的墙壁。

最初，有一个人位于左上角 (1,1) 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。

请问，该人从左上角移动至右下角 (n,m)处，至少需要移动多少次。

数据保证 (1,1)处和 (n,m)处的数字为 0，且一定至少存在一条通路。

#### 输入格式

第一行包含两个整数 n 和 m。

接下来 n 行，每行包含 m 个整数（0 或 1），表示完整的二维数组迷宫。

#### 输出格式

输出一个整数，表示从左上角移动至右下角的最少移动次数。

#### 数据范围

1≤n,m≤10

#### 输入样例：

```
5 5
0 1 0 0 0
0 1 0 1 0
0 0 0 0 0
0 1 1 1 0
0 0 0 1 0
```

#### 输出样例：

```
8
```

## 题解

广度优先遍历。

**思路**：从起点开始，往前走第一步，记录下所有第一步能走到的点。然后从所第一步能走到的点开始，往前走第二步，记录下所有第二步能走到的点，重复下去，直到走到终点。输出步数即可。

这就是广度优先遍历的思路。

**实现方式**：广度优先遍历

- 用 g 存储地图，f存储起点到其他各个点的距离。
- 从起点开始广度优先遍历地图。
- 当地图遍历完，就求出了起点到各个点的距离，输出f\[n]\[m]即可。
- `int f[N][N];`:存储起点到其他各个点的距离
- `void bfs(int a, int b)`: 广度优遍历函数。输入的是起点坐标。
- `queue<PII> q;`:用来存储每一步走到的点。
- ` while(!q.empty())循环`：循环依次取出同一步数能走到的点，再往前走一步。
- `int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};`:一个点往下一步走得时候，可以往上下左右四方向走。
- 

![微信截图_20210220145528.png](https://cdn.acwing.com/media/article/image/2021/02/20/55289_2796990173-微信截图_20210220145528.png) 


```cpp
#include <cstring>
#include <iostream>
#include <queue>
using namespace std;
typedef pair<int, int> PII;
const int N = 110;
int g[N][N];//存储地图
int f[N][N];//存储距离
int n, m;
// 广度优遍历函数。输入的是起点坐标。
void bfs(int a, int b)//广度优先遍历
{
    //用来存储每一步走到的点。
    queue<PII> q;
    q.push({a, b});
    //循环依次取出同一步数能走到的点，再往前走一步。
    while(!q.empty())
    {
        PII start = q.front();
        q.pop();
        g[start.first][start.second] = 1;
        // 一个点往下一步走得时候，可以往上下左右四方向走。
        int dx[4] = {0, 1, 0, -1}, dy[4] = {-1, 0, 1, 0};
        for(int i = 0; i < 4; i++)//往四个方向走
        {
            int x = start.first + dx[i], y = start.second + dy[i];
            if(g[x][y] == 0)//如果还没有走过
            {
                g[x][y] = 1;
                f[x][y] = f[start.first][start.second] + 1;//从当前点走过去，则距离等于当前点的距离+1.
                q.push({x, y});
            }

        }
    }
    cout << f[n][m];
}

int main()
{
    memset(g, 1, sizeof(g));
    cin >> n >>m;
    for(int i = 1; i <= n; i++)
    {
        for(int j = 1; j <= m; j++)
        {
            cin >> g[i][j];
        }
    }
    bfs(1,1);
    
}
```

## 评论

- 大佬，请问那一步是保证找到的就是最短的呢，我脑子有点笨看不出来
  - bfs函数里面的if语句确保了最短距离，图里面只有没走过的点才会向下计算距离，当最短距离出来之后，出口的点就相当于走过了，所以不会有更长的出现了。
  - bfs每个点只遍历一次喔
- 为什么要判断有没有走过?
  - 因为只要没有走过的才继续向下遍历。
- 为什么我不判断x 和 y 是否合法就会 Segmentation Fault
  - 我把迷宫四周初始化墙（数字1）了，所以不用做越界判断。
- 是不是打印路径必须使用数组模拟的队列，如果用queue的话就没法打印路径了吗？
  - 也可以，需要重新写个循环找一遍。从尾到头。判断当前点上下左右四个方向，那个点的f值等于当前点的f值-1，裸从哪个点走过来。

